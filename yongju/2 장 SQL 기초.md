# 조건 분기, 집합 연산, 윈도우 함수, 갱신

<br/><br/>

## 1. SQL과 조건 분기


### **(1) CASE식의 구문**

- **단순 CASE 식 :** 실무에서 거의 쓰지 않습니다.
- **검색 CASE 식 :** 단순 CASE 식의 기능을 모두 포함하고 있습니다. 아래는 검색 CASE식 예시 입니다.

```jsx
CASE WHEN [평가식] THEN [식]
		 WHEN [평가식] THEN [식]
			...
		 ELSE [식]
END
```

- **설명 :** 처음에 있는 WHEN 구를 먼저 확인하여 맞으면 THEN 구에서 지정한 식이 리턴되며 CASE 식은 전체 종료됩니다. 만약 조건에 맞지 않으면 다음 WHEN 구로 이동해 같은 처리를 반복하며 끝까지 맞지 않는다면 ELSE에서 지정한 식이 반환되어 종료됩니다.

<br/><br/><br/>

## 2. SQL의 집합 연산


### **(1) UNION**

- **UNION(유니온)은 합집합을 의미합니다.** 예를 들어 ADDRESS1 테이블에 데이터는 9개, ADDERSS2 테이블의 데이터는 5개가 있고, 두 테이블에 완전히 똑같은 값이 2개가 있다고 하면 UNION을 했을 때 총 행의 개수는 14개가 아닌 12개가 나오게 됩니다. 중복되는 행은 빠지기 때문입니다. 중복되는 값까지 포함하고 싶다면 UNION ALL을 쓰면됩니다. 아래는 예시 입니다.

```jsx
SELECT * FROM ADDRESS1
UNION
SELECT * FROM ADDRESS2
```

<br/>

### **(2) INTERSECT**

- **INTERSECT(인터섹트)은 교집합을 의미합니다.** 양쪽 테이블에 공통으로 존재하는 레코드를 출력합니다. 유니온 연산과 마찬가지로 중복된 것이 있다면 해당 레코드는 제외 됩니다.

```jsx
SELECT * FROM ADDRESS1
INTERSECT
SELECT * FROM ADDRESS2
```

<br/>

### **(3) EXCEPT**

- **EXCEPT는 차집합을 의미합니다.** ‘제외’라는 의미를 갖고 있습니다. 아래 코드를 봅시다.

```jsx
SELECT * FROM ADDRESS1
EXCEPT
SELECT * FROM ADDRESS2
```

- **설명 :** 위의 쿼리는 간단히 말해 ADDRESS1 - ADDRESS2 입니다. ADDRESS2에 있는 데이터가 ADDRESS1에 있다면 이것을 제외한 ADDRESS1을 보여줍니다.
- **주의 :** UNION과 INTERSECT는 테이블의 순서에 상관없이 결과가 같지만, EXCEPT는 맨 앞에 적은 테이블을 기준으로 출력됩니다.

<br/><br/><br/>

## 3. 윈도우 함수

- **윈도우 함수는 집약 기능이 없는 GROUP BY 구 입니다.** 즉, 일반적인 GROUP BY 구는 데이터를 그룹으로 나누고, 잘라 보여줄 수 있지만, 윈도우 함수는 여기서 자르기 기능만 있는 것 입니다.
- **PARTITION BY :** 윈도우 함수가 테이블을 자를 때 사용하는 구입니다. 윈도우 함수는 테이블을 자른 후 집약하지 않기 때문에 GROUP BY 와 다르게 출력되는 레코드 수가 기존 테이블과 같습니다.

```jsx
SELECT address, COUNT(*) OVER ( PARTITION BY address )
FROM ADDRESS
[실행 결과]
address | count
---------------
서울시   |  1
부산시   |  2
부산시   |  2
광주시   |  3
광주시   |  3
광주시   |  3
```

- **해설 :** 윈도우 함수의 기본적인 구문은 집약 함수(count등.) 뒤에 OVER 구와 괄호’( )’를 작성하고 괄호 안에 자를 키를 지정하는 PARTITION BY 나 ORDER BY를 입력합니다. 위 와 같은 내용을 GROUP BY로 표현하면 아래 코드와 같습니다.

```jsx
SELECT address, COUNT(*)
FROM ADDRESS
GROUP BY address;
[실행 결과]
address | count
---------------
광주시   |  3
부산시   |  2
서울시   |  1
```

- **GROUP BY와 윈도우 함수의 비교 :** 그룹 바이를 사용한 코드에서는 모든 레코드를 address로 묶은 후 광주시, 부산시, 서울시로 각각의 갯수를 출력하기 때문에 출력되는 레코드가 줄어들게 됩니다. 반면에 윈도우 함수를 사용했을 때는 레코드가 줄어드는 것 없이 그대로 출력되며 해당 지역들을 카운팅한 대로 출력됩니다. 이게 위에서 말했던 윈도우 함수의 집약 기능이 없다는 의미입니다. 자르는 기능만 있죠.
- **윈도우 함수의 다른 예시**
  - 윈도우 함수로 사용할 수 있는 함수는 COUNT, SUM, RANK, ROW_NUMBER 등이 있습니다. RANK는 이름 그대로 지정된 키로 레코드에 순위를 붙이는 함수 입니다.

```jsx
SELECT name, age, RANK() OVER( ORDER BY age DESC ) AS rnk
FROM ADDRESS;
[실행 결과]
name | age | rnk
-----------------
용주 |  30  |  1
강희 |  25  |  2
동주 |  25  |  2
지주 |  23  |  4
도희 |  22  |  5
```

- **RANK 함수의 특징 :** RANK함수는 숫자가 같으면 같은 순위로 표시합니다. 그래서 강희와 동주는 rnk가 2이며 3을 건너 뛰고 지주의 rnk가 4가 됩니다. 만약 건너 뛰는 작업 없이 구한다면 DENSE_RANK 함수를 사용 합니다. 위 예시에서 RANK()함수를 DENSE_RANK함수로 바꾸었다면 실행 결과는 아래와 같습니다.

```jsx
[실행 결과]
name | age | dens_rnk
---------------------
용주 |  30  |  1
강희 |  25  |  2
동주 |  25  |  2
지주 |  23  |  3
도희 |  22  |  4
```

- **실사용 예시**
  - ADDRESS 테이블에서 성별 별로 나이 순위(건너뛰기 있게)를 매기는 SELECT 구문 작성은 아래와 같습니다.
  ```jsx
  SELECT sex, age, RANK() OVER ( PARTITION BY sex, ORDER BY age DESC ) AS rnk
  FROM ADDRESS

  [실행 결과]
  sex | age | rnk
  ---------------
  여  |  40 |  1
  여  |  39 |  2
  여  |  39 |  2
  여  |  20 |  4
  남  |  38 |  1
  남  |  38 |  1
  남  |  20 |  3
  남  |  19 |  4
  ```

<br/><br/><br/>

## 4. 트랜잭션과 갱신 ( 삽입, 삭제, 갱신 )

### **(1) 삽입( INSERT )**

- RDB에서 데이터 등록 단위는 레코드(행)입니다. 기본적으로 INSERT 구문을 사용해 데이터를 삽입할 때는 하나의 레코드 단위로 등록됩니다. 아래는 사용 예시 입니다.

```jsx
[ 템플릿 ]
INSERT INTO 테이블명 ( 필드1, 필드2, ... )
             VALUES  ( 값1,  값2, ...  );
[ 실사용 예시 ]
INSERT INTO ADDRESS ( name, age, address )
             VALUES  ( '용주', 1, NULL );
```

- **해설 :** INSERT INTO 라는 명령어 후 테이블명을 바로 적어줍니다. 그 후 괄호’()’ 를 감싸 필드 명을 써줍니다. 그리고 VALUES 키워드 뒤에 다시 괄호’()’ 를 쓰고 값을 넣어 줍니다. 이 때 필드 순서와 값을 넣는 순서의 싱크가 맞아야 합니다. 순서가 다르면 오류가 발생하거나 원하는 값이 들어가지 않을 수 있습니다. 또한 문자열을 넣을 때는 반드시 작은 따옴표를 써야 합니다. 숫자는 그냥 적어도 상관없습니다. 또한 NULL을 넣고 싶다면 작은 따옴표를 쓰지 않고 NULL을 그대로 입력합니다.

<br/>

### **(2) 삭제( DELETE )**

- 데이터를 삭제할 때는 하나의 레코드 단위로 하는 것이 아니라 여러 개의 레코드 단위로 처리를 합니다. 그렇기 때문에 모두를 지울 수도있고, 조건을 걸어 원하는 데이터만 지울 수도 있습니다.

```jsx
[ 모든 데이터 삭제 ]
DELETE FROM ADDRESS;

[ 특정 데이터 삭제 ]
DELETE FROM ADDRESS
WHERE address = '서울시';
```

<br/>

### **(3) 갱신( UPDATE )**

- INSERT 구문으로 데이터를 삽입한 후 부분만 변경하고 싶을 때 UPDATE 구문을 사용합니다.

```jsx
[ 템플릿 ]
UPDATE 테이블명
  SET 필드이름 = 값,
      필드이름 = 값
WHERE 조건필드이름 = 조건값;

[ 실사용 예시 ]
UPDATE ADDRESS
  SET  address = '서울시',
       age = 19
WHERE  name = '용주';
```

- **해설 :** UPDATE 구문으로 값을 변경할 때 SET 키워드 후에 변경 원하는 필드명들과 변경원하는 값들을 적어 줍니다. 이 때 구문은 콜론( , ) 으로 합니다. 그리고 특정 조건을 주기 위해 WHERE에 조건 필드와 조건 값을 걸어줍니다. 여기서 중요한 점은 WHERE 조건에 적힌 필드와 값을 가진 레코드가 여러개라면 여러개의 값이 동시에 수정됩니다.
